/**
 * bit(N) Compiler - C Code Generator Implementation
 * Quick fix version - minimal implementation that compiles
 */

#include "codegen.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

CodegenContext* codegen_init(const char *output_file, const char *target) {
    CodegenContext *ctx = malloc(sizeof(CodegenContext));
    if (!ctx) return NULL;
    
    ctx->output = fopen(output_file, "w");
    if (!ctx->output) {
        free(ctx);
        return NULL;
    }
    
    ctx->indent_level = 0;
    ctx->target_arch = malloc(strlen(target) + 1);
    strcpy(ctx->target_arch, target);
    ctx->target_abi = "eabi";
    ctx->use_volatile = 1;
    ctx->inline_asm = 1;
    
    return ctx;
}

void codegen_indent(CodegenContext *ctx) {
    for (int i = 0; i < ctx->indent_level * 4; i++) {
        fputc(' ', ctx->output);
    }
}

void codegen_write(CodegenContext *ctx, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    
    char buffer[4096];
    vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);
    
    const char *ptr = buffer;
    int at_line_start = 1;
    
    while (*ptr) {
        if (at_line_start && *ptr != '\n' && *ptr != '\0') {
            codegen_indent(ctx);
            at_line_start = 0;
        }
        
        if (*ptr == '\n') {
            at_line_start = 1;
        }
        
        fputc(*ptr, ctx->output);
        ptr++;
    }
}

char* sanitize_identifier(const char *name) {
    char *safe = malloc(strlen(name) + 1);
    int j = 0;
    
    for (int i = 0; name[i]; i++) {
        if (isalnum(name[i]) || name[i] == '_') {
            safe[j++] = name[i];
        } else if (name[i] == '.') {
            safe[j++] = '_';
        }
    }
    safe[j] = '\0';
    return safe;
}

static void codegen_file_header(CodegenContext *ctx, const char *source_file) {
    codegen_write(ctx,
        "/**\n"
        " * Auto-generated from: %s\n"
        " * Generated by bit(N) compiler\n"
        " * DO NOT EDIT MANUALLY\n"
        " */\n\n", source_file);
    
    codegen_write(ctx,
        "#ifndef __BITN_GENERATED_H\n"
        "#define __BITN_GENERATED_H\n\n"
        "#include <stdint.h>\n"
        "#include <stdbool.h>\n\n");
    
    if (ctx->use_volatile) {
        codegen_write(ctx, "#define MMIO_REG volatile uint32_t\n\n");
    } else {
        codegen_write(ctx, "#define MMIO_REG uint32_t\n\n");
    }
}

static void codegen_file_footer(CodegenContext *ctx) {
    codegen_write(ctx, "\n#endif // __BITN_GENERATED_H\n");
}

int codegen_peripheral(CodegenContext *ctx, ASTPeripheral *periph) {
    if (!periph || !periph->name) return -1;
    
    char *safe_name = sanitize_identifier(periph->name);
    
    codegen_write(ctx, "// Peripheral: %s\n", periph->name);
    codegen_write(ctx, "// Base Address: 0x%08lx\n", periph->base_address);
    /* Note: periph->size field may not exist in your AST */
    
    codegen_write(ctx, "typedef struct {\n");
    ctx->indent_level++;
    
    if (periph->registers) {
        for (size_t i = 0; i < periph->register_count; i++) {
            ASTRegister *reg = periph->registers[i];
            codegen_write(ctx, "MMIO_REG %s; // @ offset 0x%lx\n",
                sanitize_identifier(reg->name), reg->offset);
        }
    }
    
    ctx->indent_level--;
    codegen_write(ctx, "} %s_t;\n\n", safe_name);
    
    codegen_write(ctx, "#define %s ((volatile %s_t *)0x%08lx)\n\n",
        safe_name, safe_name, periph->base_address);
    
    free(safe_name);
    return 0;
}

int codegen_register(CodegenContext *ctx, ASTRegister *reg) {
    if (!reg || !reg->name) return -1;
    
    char *safe_reg_name = sanitize_identifier(reg->name);
    
    codegen_write(ctx, "// Register: %s (Offset: 0x%lx)\n", reg->name, reg->offset);
    codegen_write(ctx, "// Fields: %zu\n", reg->field_count);

    codegen_write(ctx, "typedef struct {\n");
    ctx->indent_level++;
    
    if (reg->fields) {
        for (size_t i = 0; i < reg->field_count; i++) {
            ASTField *field = reg->fields[i];
            
            /* TODO: Update these field names to match your ASTField structure */
            /* Currently commented out because field->high_bit, field->low_bit don't exist */
            
            codegen_write(ctx, "uint32_t %s; // Field placeholder\n",
                sanitize_identifier(field->name));
        }
    }
    
    ctx->indent_level--;
    codegen_write(ctx, "} %s_bitfield_t;\n\n", safe_reg_name);
    
    free(safe_reg_name);
    return 0;
}

int codegen_field_accessors(CodegenContext *ctx, ASTRegister *reg) {
    if (!reg || !reg->fields) return -1;
    
    char *safe_reg = sanitize_identifier(reg->name);
    
    for (size_t i = 0; i < reg->field_count; i++) {
        ASTField *field = reg->fields[i];
        char *safe_field = sanitize_identifier(field->name);
        
        /* TODO: Update these to use your actual ASTField member names */
        codegen_write(ctx, "// Field accessor for %s\n", safe_field);
        
        free(safe_field);
    }
    
    free(safe_reg);
    return 0;
}

int codegen_helpers(CodegenContext *ctx) {
    codegen_write(ctx,
        "// Utility Macros\n"
        "#define BIT_SET(reg, bit) ((reg) |= (1U << (bit)))\n"
        "#define BIT_CLR(reg, bit) ((reg) &= ~(1U << (bit)))\n"
        "#define BIT_TST(reg, bit) ((reg) & (1U << (bit)))\n"
        "#define BIT_TGL(reg, bit) ((reg) ^= (1U << (bit)))\n\n");
    
    return 0;
}

int codegen_generate(CodegenContext *ctx, ASTProgram *program) {
    if (!ctx || !program) return -1;
    
    codegen_file_header(ctx, "bitn source");
    codegen_helpers(ctx);
    
    if (program->peripherals) {
        for (size_t i = 0; i < program->peripheral_count; i++) {
            ASTPeripheral *periph = program->peripherals[i];
            
            codegen_peripheral(ctx, periph);
            
            if (periph->registers) {
                for (size_t j = 0; j < periph->register_count; j++) {
                    ASTRegister *reg = periph->registers[j];
                    codegen_register(ctx, reg);
                    codegen_field_accessors(ctx, reg);
                }
            }
            
            codegen_write(ctx, "\n");
        }
    }
    
    codegen_file_footer(ctx);
    
    return 0;
}

void codegen_cleanup(CodegenContext *ctx) {
    if (!ctx) return;
    
    if (ctx->output) {
        fclose(ctx->output);
    }
    
    if (ctx->target_arch) {
        free(ctx->target_arch);
    }
    
    free(ctx);
}
