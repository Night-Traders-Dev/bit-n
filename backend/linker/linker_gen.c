/**
 * bit(N) Compiler - Linker Script Generator Implementation
 */

#include "linker_gen.h"
#include <stdlib.h>
#include <string.h>

LinkerContext* linker_init(const char *output_file, const char *target) {
    LinkerContext *ctx = malloc(sizeof(LinkerContext));
    if (!ctx) return NULL;
    
    ctx->output = fopen(output_file, "w");
    if (!ctx->output) {
        free(ctx);
        return NULL;
    }
    
    ctx->regions = malloc(sizeof(MemoryRegion) * 10);
    ctx->region_count = 0;
    ctx->target = malloc(strlen(target) + 1);
    strcpy(ctx->target, target);
    ctx->stack_size = 0x1000;
    ctx->heap_size = 0x1000;
    
    return ctx;
}

int linker_add_region(LinkerContext *ctx, const char *name,
                     uint32_t base, uint32_t size, const char *type) {
    if (!ctx || ctx->region_count >= 10) return -1;
    
    MemoryRegion *region = &ctx->regions[ctx->region_count];
    region->name = malloc(strlen(name) + 1);
    strcpy(region->name, name);
    region->base = base;
    region->size = size;
    region->type = malloc(strlen(type) + 1);
    strcpy(region->type, type);
    
    ctx->region_count++;
    return 0;
}

int linker_generate(LinkerContext *ctx) {
    if (!ctx || !ctx->output) return -1;
    
    fprintf(ctx->output,
        "/**\n"
        " * Auto-generated ARM Linker Script for %s\n"
        " * Generated by bit(N) compiler\n"
        " * Target: %s\n"
        " */\n\n", ctx->target, ctx->target);
    
    fprintf(ctx->output, "MEMORY\n{\n");
    for (int i = 0; i < ctx->region_count; i++) {
        MemoryRegion *region = &ctx->regions[i];
        fprintf(ctx->output,
            "  %s (%-4s) : ORIGIN = 0x%08x, LENGTH = 0x%x\n",
            region->name, region->type, region->base, region->size);
    }
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SECTIONS\n{\n");
    
    fprintf(ctx->output,
        "  .vectors :\n"
        "  {\n"
        "    KEEP(*(.vectors))\n"
        "  } > FLASH\n\n");
    
    fprintf(ctx->output,
        "  .text :\n"
        "  {\n"
        "    *(.text*)\n"
        "    *(.rodata*)\n"
        "  } > FLASH\n\n");
    
    fprintf(ctx->output,
        "  .data :\n"
        "  {\n"
        "    PROVIDE(_sdata = .);\n"
        "    *(.data*)\n"
        "    PROVIDE(_edata = .);\n"
        "  } > RAM AT > FLASH\n"
        "  PROVIDE(_sidata = LOADADDR(.data));\n\n");
    
    fprintf(ctx->output,
        "  .bss :\n"
        "  {\n"
        "    PROVIDE(_sbss = .);\n"
        "    *(.bss*)\n"
        "    *(COMMON)\n"
        "    PROVIDE(_ebss = .);\n"
        "  } > RAM\n\n");
    
    fprintf(ctx->output,
        "  .heap :\n"
        "  {\n"
        "    PROVIDE(_heap_start = .);\n"
        "    . += 0x%x;\n"
        "    PROVIDE(_heap_end = .);\n"
        "  } > RAM\n\n",
        ctx->heap_size);
    
    fprintf(ctx->output,
        "  .stack :\n"
        "  {\n"
        "    PROVIDE(_stack_start = .);\n"
        "    . += 0x%x;\n"
        "    PROVIDE(_stack_end = .);\n"
        "  } > RAM\n\n",
        ctx->stack_size);
    
    fprintf(ctx->output, "}\n");
    
    return 0;
}

void linker_cleanup(LinkerContext *ctx) {
    if (!ctx) return;
    
    if (ctx->output) {
        fclose(ctx->output);
    }
    
    for (int i = 0; i < ctx->region_count; i++) {
        free(ctx->regions[i].name);
        free(ctx->regions[i].type);
    }
    
    if (ctx->regions) {
        free(ctx->regions);
    }
    
    if (ctx->target) {
        free(ctx->target);
    }
    
    free(ctx);
}
